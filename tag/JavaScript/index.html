<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - My Blog</title><meta name="gridsome:hash" content="2b0713881518a083297269ac707be987ac2ab4f7"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Notes about tech, business and some random thoughts"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/assets/css/0.styles.d35d62bf.css" as="style"><link rel="preload" href="/assets/js/app.f103f42b.js" as="script"><link rel="preload" href="/assets/js/page--src-templates-tag-vue.eb85649a.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules-gridsome-app-pages-404-vue.8bffd1bb.js"><link rel="prefetch" href="/assets/js/page--src-pages-archives-vue.9865e88a.js"><link rel="prefetch" href="/assets/js/page--src-pages-index-vue.cd5624df.js"><link rel="prefetch" href="/assets/js/page--src-templates-post-vue.f5d70c84.js"><link rel="stylesheet" href="/assets/css/0.styles.d35d62bf.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← My Blog
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # JavaScript
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">NPM Adalah</h2><p class="post-card__description">NPM (Node Package Manager) adalah pengelola paket default untuk runtime JavaScript Node.js. NPM terdiri dari dua bagian utama: di sisi kita sebagai klien menggunakan command line interface (CLI) untuk menginstall dan menerbitkan paket, dan repositori online atau disebut npm registry yang menghosting paket-paket kode open source Javascript seperti Node.JS, aplikasi web front-end, aplikasi mobile, robot, router, dan kebutuhan lain yang tak terhitung jumlahnya dari komunitas JavaScript. Banyak paket kode yang diterbitkan di NPM dengan berbagai macam fungsinya bisa mempercepat proses pengembangan web kita.</p><div class="post-meta post-card__meta">
   Posted 20. February 2021.
   <strong>3 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/npm-adalah/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">Cara Menggunakan NPM</h2><p class="post-card__description">NPM (*Node Package Manager*) adalah pengelola paket default untuk runtime JavaScript Node.js. NPM terdiri dari dua bagian utama: CLI (command line interface) untuk menerbitkan (*publish*) atau mengunduh paket, dan repositori online yang menghosting paket-paket JavaScript</p><div class="post-meta post-card__meta">
   Posted 17. February 2021.
   <strong>2 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/cara-menggunakan-npm/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">JAMStack Adalah</h2><p class="post-card__description">JAMstack adalah arsitektur software yang disusun dari 3 komponen: Javascript, API, dan Markup. Arsitektur JAMStack dirancang untuk membuat website lebih cepat, lebih aman, dan lebih mudah untuk diskalakan.</p><div class="post-meta post-card__meta">
   Posted 16. February 2021.
   <strong>3 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/jam-stack-adalah/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2021. </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"JavaScript","belongsTo":{"edges":[{"node":{"title":"NPM Adalah","path":"\u002Fnpm-adalah\u002F","date":"20. February 2021","timeToRead":3,"description":"NPM (Node Package Manager) adalah pengelola paket default untuk runtime JavaScript Node.js. NPM terdiri dari dua bagian utama: di sisi kita sebagai klien menggunakan command line interface (CLI) untuk menginstall dan menerbitkan paket, dan repositori online atau disebut npm registry yang menghosting paket-paket kode open source Javascript seperti Node.JS, aplikasi web front-end, aplikasi mobile, robot, router, dan kebutuhan lain yang tak terhitung jumlahnya dari komunitas JavaScript. Banyak paket kode yang diterbitkan di NPM dengan berbagai macam fungsinya bisa mempercepat proses pengembangan web kita.","content":"\u003Cp\u003ENPM (\u003Cem\u003ENode Package Manager\u003C\u002Fem\u003E) adalah pengelola paket default untuk runtime JavaScript Node.js. NPM dibuat pada tahun 2009 sebagai proyek open source untuk membantu pengembang JavaScript berbagi paket modul kode dengan mudah. NPM terdiri dari dua bagian utama: di sisi kita sebagai klien menggunakan command line interface (CLI) untuk menginstall dan menerbitkan paket, dan repositori online atau disebut npm registry yang menghosting paket-paket kode open source Javascript seperti Node.JS, aplikasi web front-end, aplikasi mobile, robot, router, dan kebutuhan lain yang tak terhitung jumlahnya dari komunitas JavaScript. Banyak paket kode yang diterbitkan di NPM dengan berbagai macam fungsinya bisa mempercepat proses pengembangan web kita.\u003C\u002Fp\u003E\n\u003Ch2 id=\"npm-init\"\u003E\u003Ca href=\"#npm-init\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003Enpm init\u003C\u002Fh2\u003E\n\u003Cp\u003ESemua dimulai dari file package.json. Setiap project JavaScript - baik itu Node.js atau aplikasi browser - dapat dicakup sebagai paket npm dengan informasi paketnya sendiri. Tugas package.json adalah mendeskripsikan proyek tersebut. Itu seperti daftar komposisi pada bungkus makanan. package.json dibuat ketika \u003Ccode class=\"language-text\"\u003Enpm init\u003C\u002Fcode\u003E dijalankan untuk menginisialisasi proyek JavaScript \u002F Node.js. Di dalamnya terdapat informasi, diantaranya metadata dasar yang disediakan oleh pengembang:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Ename: nama library \u002F proyek JavaScript Anda\u003C\u002Fli\u003E\n\u003Cli\u003Eversion: versi proyek Anda. Bagian ini bisa berguna sebagai sumber versi deploy.\u003C\u002Fli\u003E\n\u003Cli\u003Edescription: deskripsi proyek\u003C\u002Fli\u003E\n\u003Cli\u003Elisensi: lisensi proyek\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"npm-script\"\u003E\u003Ca href=\"#npm-script\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003Enpm script\u003C\u002Fh2\u003E\n\u003Cp\u003Epackage.json juga mendukung properti scripts yang dapat didefinisikan untuk menjalankan command line yang diinstal dalam konteks lokal sebuah proyek. Misalnya, bagian skrip dari proyek npm dapat terlihat seperti ini:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E    {\n      &quot;scripts&quot;: {\n        &quot;build&quot;: &quot;tsc&quot;,\n        &quot;format&quot;: &quot;prettier --write ** \u002F *. ts&quot;,\n        &quot;format-check&quot;: &quot;prettier --check ** \u002F *. ts&quot;,\n        &quot;lint&quot;: &quot;eslint src \u002F ** \u002F *. ts&quot;,\n        &quot;pack&quot;: &quot;ncc build&quot;,\n        &quot;test&quot;: &quot;jest&quot;,\n        &quot;all&quot;: &quot;npm run build &amp;&amp; npm run format &amp;&amp; npm run lint &amp;&amp; npm run pack &amp;&amp; npm test&quot;\n      }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESkrip di atas memberitahu paket apa saja yang dijalankan dengan skrip perintah yang tertulis. Eslint, prettier, ncc, jest tidak harus diinstal sebagai executable global melainkan hanya lokal untuk proyek Anda di dalam folder node_modules \u002F .bin \u002F.\u003C\u002Fp\u003E\n\u003Ch2 id=\"dependencies-vs-devdependecies\"\u003E\u003Ca href=\"#dependencies-vs-devdependecies\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003Edependencies vs devDependecies\u003C\u002Fh2\u003E\n\u003Cp\u003EBagian ini ditulis dalam bentuk key value object dengan nama library npm sebagai key dan versi library yang ditulis dengan format semantik sebagai value. Ini adalah contoh dari templatenya:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E    {\n      &quot;dependencies&quot;: {\n        &quot;@ actions \u002F core&quot;: &quot;^ 1.2.3&quot;,\n        &quot;@ actions \u002F github&quot;: &quot;^ 2.1.1&quot;\n      },\n      &quot;devDependencies&quot;: {\n        &quot;@ types \u002F jest&quot;: &quot;^ 25.1.4&quot;,\n        &quot;@ types \u002F node&quot;: &quot;^ 13.9.0&quot;,\n        &quot;@ typescript-eslint \u002F parser&quot;: &quot;^ 2.22.0&quot;,\n        &quot;@ zeit \u002F ncc&quot;: &quot;^ 0.21.1&quot;,\n        &quot;eslint&quot;: &quot;^ 6.8.0&quot;,\n        &quot;eslint-plugin-github&quot;: &quot;^ 3.4.1&quot;,\n        &quot;eslint-plugin-jest&quot;: &quot;^ 23.8.2&quot;,\n        &quot;jest&quot;: &quot;^ 25.1.0&quot;,\n        &quot;jest-circus&quot;: &quot;^ 25.1.0&quot;,\n        &quot;js-yaml&quot;: &quot;^ 3.13.1&quot;,\n        &quot;prettier&quot;: &quot;^ 1.19.1&quot;,\n        &quot;ts-jest&quot;: &quot;^ 25.2.1&quot;,\n        &quot;typescript&quot;: &quot;^ 3.8.3&quot;\n      }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EDependensi ini nantinya akan diinstal ketika menjalankan perintah \u003Ccode class=\"language-text\"\u003Enpm install\u003C\u002Fcode\u003E dengan flag \u003Ccode class=\"language-text\"\u003E--save\u003C\u002Fcode\u003E dan \u003Ccode class=\"language-text\"\u003E--save-dev\u003C\u002Fcode\u003E. Flag tersebut dimaksudkan untuk memberi tahu dependensi akan digunakan masing-masing untuk lingkungan produksi dan pengembangan \u002F pengujian. Kami akan menggali lebih dalam tentang pemasangan paket-paket ini di bagian selanjutnya. Selain itu penting untuk memahami kemungkinan tanda yang muncul sebelum versi semantik (baca selengkapnya tentang semantic versioning):\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E^: rilis minor terbaru. Misalnya, spesifikasi ^ 1.0.4 mungkin menginstal versi 1.3.0 jika itu adalah versi minor terbaru dalam 1 seri utama.\u003C\u002Fli\u003E\n\u003Cli\u003E~: rilis patch terbaru. Dengan cara yang sama seperti ^ untuk rilis minor, spesifikasi ~ 1.0.4 mungkin menginstal versi 1.0.7 jika itu adalah versi minor terbaru dalam seri 1.0 minor.\nSemua versi paket yang tepat ini akan didokumentasikan dalam file package-lock.json yang dihasilkan.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"package-lockjson\"\u003E\u003Ca href=\"#package-lockjson\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003Epackage-lock.json\u003C\u002Fh2\u003E\n\u003Cp\u003EFile ini menjelaskan versi pasti dari dependensi yang digunakan dalam proyek JavaScript npm. Jika dianalogikan seperti makanan package.json adalah label bahan dengan deskripsi secara umum, di dalam package-lock.json semua terlihat lebih detil. Dan sebagaimana makanan kita biasanya hanya membaca secara umum komposisinya, tidak perlu membaca kapan bawang dalam sebuah makanan dipanen dsb. package-lock.json tidak dimaksudkan untuk dibaca baris demi baris oleh pengembang. package-lock.json biasanya dibuat oleh perintah npm install, dan juga dibaca oleh alat NPM CLI kita untuk memastikan reproduksi lingkungan build untuk proyek dengan perintah \u003Ccode class=\"language-text\"\u003Enpm ci\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003ESumber: \u003Ca href=\"https:\u002F\u002Fwww.freecodecamp.org\u002Fnews\u002Fwhat-is-npm-a-node-package-manager-tutorial-for-beginners\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Efreecodecamp.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n"}},{"node":{"title":"Cara Menggunakan NPM","path":"\u002Fcara-menggunakan-npm\u002F","date":"17. February 2021","timeToRead":2,"description":"NPM (*Node Package Manager*) adalah pengelola paket default untuk runtime JavaScript Node.js. NPM terdiri dari dua bagian utama: CLI (command line interface) untuk menerbitkan (*publish*) atau mengunduh paket, dan repositori online yang menghosting paket-paket JavaScript","content":"\u003Cp\u003ENPM (\u003Cem\u003ENode Package Manager\u003C\u002Fem\u003E) adalah pengelola paket default untuk runtime JavaScript Node.js. NPM terdiri dari dua bagian utama: CLI (command line interface) untuk menerbitkan (\u003Cem\u003Epublish\u003C\u002Fem\u003E) atau mengunduh paket, dan repositori online yang menghosting paket-paket JavaScript. Konsepnya secara sederhana mirip dengan apps market, hanya saja ini disediakan untuk pengembang perangkat lunak.\u003C\u002Fp\u003E\n\u003Ch2 id=\"menggunakan-npm\"\u003E\u003Ca href=\"#menggunakan-npm\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMenggunakan npm\u003C\u002Fh2\u003E\n\u003Cp\u003EDi sisi pengguna, kita bisa menginstall paket-paket yang tersedia di NPM dengan menjalankan perintah di CLI. Jadi ada baiknya mengetahui cara menggunakan alat yang powerfull ini.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003Enpm install\u003C\u002Fstrong\u003E - adalah perintah yang paling umum digunakan saat mengembangkan aplikasi JavaScript \u002F Node.js saat ini. Secara default, npm install \u003Cpackage-name\u003E akan menginstal versi terbaru dari sebuah paket dengan tanda versi ^. Instalasi npm dalam konteks sebuah project adalah mengunduh paket ke folder node_modules di dalam direktori project sesuai dengan spesifikasi package.json, mengupdate versi paket (dan pada gilirannya meregenerasi package-lock.json) di mana pun itu berdasarkan pada ^ dan ~ pencocokan versi. Kita dapat menambahkan flag global (-g) jika ingin menginstal paket dalam konteks global yang dapat digunakan di direktori manapun dalam komputer (umumnya pada paket peralatan command line seperti live server misalnya). npm telah membuat penginstalan paket JavaScript begitu mudah sehingga perintah ini sering digunakan secara tidak benar. Akibatnya npm menjadi banyak lelucon programmer karena menghasilkan folder node_module dengan ukuran sangat besar.\u003C\u002Fp\u003E\n\u003Cp\u003EDi sinilah --production flag berperan. Di bagian sebelumnya, kita membahas dependensi dan devDependency yang dimaksudkan untuk penggunaan masing-masing dalam lingkungan produksi dan pengembangan \u002F pengujian. Dengan melampirkan --production flag ke perintah npm install, kita hanya akan menginstal paket dari dependensi, sehingga secara drastis mengurangi ukuran node_modules. Kita hanya menginstal apa yang benar-benar diperlukan agar aplikasi dapat aktif dan berjalan.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003Enpm ci\u003C\u002Fstrong\u003E - jika npm install --production optimal untuk lingkungan produksi, haruskah ada perintah yang optimal untuk pengaturan pengembangan lokal dan pengujian? Gunakan npm ci. Sama seperti bagaimana jika package-lock.json belum ada dalam proyek yang dihasilkan setiap kali npm install dipanggil, npm ci menggunakan file ini untuk mengunduh versi yang tepat dari setiap paket yang bergantung pada proyek. Ini adalah cara kami memastikan bahwa konteks proyek kami tetap sama persis di berbagai mesin, baik laptop kami yang digunakan untuk pengembangan atau lingkungan build CI (Continuous Integration) seperti Github Actions.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003Enpm audit\u003C\u002Fstrong\u003E - Dengan banyaknya paket yang telah diterbitkan dan dapat dengan mudah diinstal, paket npm rentan terhadap penulis yang buruk dengan niat jahat seperti ini.Menyadari adanya masalah pada ekosistem tersebut, organisasi npm.js memunculkan ide tentang audit npm. Mereka memelihara daftar celah keamanan yang dapat diaudit oleh pengembang terhadap ketergantungan mereka menggunakan perintah audit npm. npm audit memberikan informasi kepada pengembang tentang kerentanan dan apakah ada versi dengan perbaikan untuk ditingkatkan. Sebagai contoh,\u003C\u002Fp\u003E\n\u003Cp\u003EJika remediasi tersedia di upgrade versi non-breaking berikutnya, npm audit fix dapat digunakan untuk mengupgrade versi dependensi yang terpengaruh secara otomatis.\u003C\u002Fp\u003E\n\u003Cp\u003ESumber: \u003Ca href=\"https:\u002F\u002Fwww.freecodecamp.org\u002Fnews\u002Fwhat-is-npm-a-node-package-manager-tutorial-for-beginners\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Efreecodecamp.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n"}},{"node":{"title":"JAMStack Adalah","path":"\u002Fjam-stack-adalah\u002F","date":"16. February 2021","timeToRead":3,"description":"JAMstack adalah arsitektur software yang disusun dari 3 komponen: Javascript, API, dan Markup. Arsitektur JAMStack dirancang untuk membuat website lebih cepat, lebih aman, dan lebih mudah untuk diskalakan.","content":"\u003Cp\u003EJAMstack adalah arsitektur software yang disusun dari 3 komponen: Javascript, API, dan Markup. Arsitektur JAMStack dirancang untuk membuat website lebih cepat, lebih aman, dan lebih mudah untuk diskalakan. Prinsip inti JAMStack adalah \u003Cem\u003Epre-rendering\u003C\u002Fem\u003E dan \u003Cem\u003Edecoupling\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EPre-rendering\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E berarti halaman website (markup) yang mewakili view adalah file statis yang telah dibuild (berupa file html). Web server tidak perlu melakukan render setiap kali user melakukan request. Dengan Jamstack, front-end dibangun terlebih dahulu menjadi halaman statis beserta aset yang sudah sangat dioptimalkan selama proses build. Proses \u003Cem\u003Epre-rendering\u003C\u002Fem\u003E ini menghasilkan website yang dapat disajikan langsung dari CDN. Dengan begitu akan mengurangi biaya, kompleksitas, dan risiko server dinamis sebagai infrastruktur penting.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EDecoupling\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E berarti memisahkan antara sistem dengan service. Masing-masing komponen berdiri sendiri dan berkomunikasi menggunakan API. Pada praktik kebanyakan, halaman website dirender di sisi server setiap kali user melakukan request. Ini yang disebut dengan website dinamis, misalnya tampilan sebuah website (view) dirender dengan PHP atau bahasa pemrograman lainnya. Dengan metode itu kebutuhan server akan meningkat seiring dengan penambahan pengguna. Ini membuat sitem semakin besar dan kompleks.\u003C\u002Fp\u003E\n\u003Cp\u003EIstilah \"JAMStack\" muncul saat Matt Biilmann dan Chris Bach membuat alur kerja pengembangan web modern di Netlify, mereka mencari istilah mudah untuk merujuk pada sebuah pendekatan arsitektural itu untuk digunakan dalam percakapan. Jamstack mencakup banyak dasar-dasar arsitektur web yang ada, sehingga mereka menciptakan istilah Jamstack untuk membantu orang-orang membicarakannya dengan lebih ringkas.\u003C\u002Fp\u003E\n\u003Cp\u003EDengan begitu banyak tool populer untuk membuat website statis, seperti Gatsby, Hugo, Jekyll, Eleventy, NextJS, dan masih banyak lagi, banyak pengembang web sudah terbiasa dengan alat yang dibutuhkan untuk mengembangkan Jamstack.\u003C\u002Fp\u003E\n\u003Ch2 id=\"mengapa-menggunakan-jamstack\"\u003E\u003Ca href=\"#mengapa-menggunakan-jamstack\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMengapa menggunakan JAMStack\u003C\u002Fh2\u003E\n\u003Cp\u003EArsitektur JAMStack dapat memberi beberapa kelebihan pada website dan alur kerja pengembangan. Berikut beberapa kelebihannya\u003C\u002Fp\u003E\n\u003Ch4 id=\"keamanan\"\u003E\u003Ca href=\"#keamanan\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EKeamanan\u003C\u002Fh4\u003E\n\u003Cp\u003EJamstack menghilangkan penggunaan bagian dinamis dalam infrastruktur hosting sehingga menghasilkan lebih sedikit penggunaan server dan sistem menjadi lebih sulit untuk diserang.Tampilan halaman web dan aset adalah file yang dibuat secara pre-render, ini memungkinkan hanya memberikan akses baca saja (read-only) ke hosting. Hal itu mengurangi risiko serangan lebih jauh. Sementara layanan yang sifatnya dinamis dapat disediakan oleh vendor dengan tim yang dedicated atau pihak ketiga yang sudah memiliki keamanan sistem.\u003C\u002Fp\u003E\n\u003Ch4 id=\"skala\"\u003E\u003Ca href=\"#skala\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESkala\u003C\u002Fh4\u003E\n\u003Cp\u003EArsitektur yang populer saat ini menangani beban lalu lintas yang padat dengan menambahkan logika untuk membuat cache pada tampilan dan sumber daya yang sering diakses. Jamstack secara natural menyediakan ini. Karena halaman web dapat disajikan sepenuhnya dari CDN, tidak ada logika atau alur kerja yang rumit untuk menentukan aset apa yang dapat di-cache dan kapan. Bahkan dengan website Jamstack semuanya dapat disimpan dalam cache di CDN. Dengan begitu penerapannya bisa lebih sederhana dan kapasitas loadnya bisa lebih besar.\u003C\u002Fp\u003E\n\u003Ch4 id=\"performa\"\u003E\u003Ca href=\"#performa\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPerforma\u003C\u002Fh4\u003E\n\u003Cp\u003EKita semua tau kecepatan memuat (\u003Cem\u003Eload\u003C\u002Fem\u003E) halaman berdampak pada pengalaman pengguna dan konversi. Website Jamstack menghilangkan kebutuhan untuk menghasilkan tampilan halaman di server setiap kali ada request, karena halaman telah dibuat sebelumnya (\u003Cem\u003Epre-rendered\u003C\u002Fem\u003E). Dengan semua halaman telah tersedia di CDN yang dekat dengan pengguna dan siap untuk ditayangkan, kinerja yang sangat tinggi dimungkinkan tanpa menggunakan infrastruktur yang mahal atau kompleks.\u003C\u002Fp\u003E\n\u003Ch4 id=\"pemeliharaan\"\u003E\u003Ca href=\"#pemeliharaan\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPemeliharaan\u003C\u002Fh4\u003E\n\u003Cp\u003EKetika kompleksitas hosting berkurang, berkurang pula tugas pemeliharaan. Situs yang dibuat sebelumnya (\u003Cem\u003Epre-rendered\u003C\u002Fem\u003E), disajikan langsung dari host sederhana atau langsung dari CDN sehingga tidak memerlukan tim ahli untuk memastikannya tetap bisa diakses. Pekerjaan yang berhubungan dengan tampilan halaman sudah selesai selama pembuatan, jadi website yang dihasilkan sudah stabil dan dapat dihosting tanpa server yang mungkin memerlukan patching, update, dan maintenance.\u003C\u002Fp\u003E\n\u003Ch4 id=\"portabilitas\"\u003E\u003Ca href=\"#portabilitas\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPortabilitas\u003C\u002Fh4\u003E\n\u003Cp\u003ESitus Jamstack bersifat \u003Cem\u003Epre-rendered\u003C\u002Fem\u003E atau sudah dibuat sebelumnya. Itu berarti kita dapat menghostingnya dari berbagai layanan hosting dan memiliki kemampuan lebih besar untuk memindahkannya ke host pilihan Anda. Kita tidak perlu memindahkan banyak sekali file, cukup source file halaman web saja. Solusi hosting statis sederhana apa pun harus dapat melayani situs Jamstack. Kita tidak lagi terkunci pada satu infrastruktur.\u003C\u002Fp\u003E\n\u003Ch4 id=\"pengalaman-pengembang\"\u003E\u003Ca href=\"#pengalaman-pengembang\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPengalaman Pengembang\u003C\u002Fh4\u003E\n\u003Cp\u003EJamstack adalah sebuah arsitektur, bukan alat yang spesifik. Website Jamstack dapat dibangun dengan berbagai alat. Itu tidak bergantung pada teknologi eksklusif atau framework yang eksotis dan sedikit diketahui. Sebaliknya, mereka mengembangkan alat dan konvensi yang tersedia secara luas.\u003C\u002Fp\u003E\n\u003Cp\u003ESumber: \u003Ca href=\"https:\u002F\u002Fjamstack.org\u002Fwhat-is-jamstack\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ejamstack.org\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.f103f42b.js" defer></script><script src="/assets/js/page--src-templates-tag-vue.eb85649a.js" defer></script>
  </body>
</html>